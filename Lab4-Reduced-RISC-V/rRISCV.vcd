$version Generated by VerilatedVcd $end
$date Thu Nov 24 11:29:21 2022 $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire 32 = a0 [31:0] $end
  $var wire  1 ; clk $end
  $var wire  1 < rst $end
  $scope module rRISCV $end
   $var wire  1 5 ALUctrl $end
   $var wire  1 6 ALUsrc $end
   $var wire 32 @ D_WIDTH [31:0] $end
   $var wire  1 8 EQ $end
   $var wire 32 + ImmOp [31:0] $end
   $var wire  1 9 ImmSrc $end
   $var wire 32 ) PC [31:0] $end
   $var wire  1 4 PCsrc $end
   $var wire  1 7 RegWrite $end
   $var wire 32 = a0 [31:0] $end
   $var wire  1 ; clk $end
   $var wire 32 * instr [31:0] $end
   $var wire  1 < rst $end
   $scope module Control $end
    $var wire  1 5 ALUctrl $end
    $var wire  1 6 ALUsrc $end
    $var wire  1 8 EQ $end
    $var wire  1 9 ImmSrc $end
    $var wire  1 4 PCsrc $end
    $var wire  1 7 RegWrite $end
    $var wire  1 - addi $end
    $var wire  1 . bne $end
    $var wire  7 , instr [6:0] $end
   $upscope $end
   $scope module InstrMem $end
    $var wire 32 ) A [31:0] $end
    $var wire 32 @ ADDRESS_WIDTH [31:0] $end
    $var wire 32 @ DATA_WIDTH [31:0] $end
    $var wire 32 * RD [31:0] $end
    $var wire  8 # rom_array[-1] [7:0] $end
    $var wire  8 $ rom_array[0] [7:0] $end
   $upscope $end
   $scope module PCregister $end
    $var wire 32 @ WIDTH [31:0] $end
    $var wire  1 ; clk $end
    $var wire 32 + immop [31:0] $end
    $var wire 32 ) pc [31:0] $end
    $var wire  1 4 pcsrc $end
    $var wire  1 < rst $end
   $upscope $end
   $scope module RedBlock $end
    $var wire  1 5 ALUctrl $end
    $var wire 32 % ALUop1 [31:0] $end
    $var wire 32 : ALUop2 [31:0] $end
    $var wire 32 > ALUout [31:0] $end
    $var wire  1 6 ALUsrc $end
    $var wire 32 @ D_WIDTH [31:0] $end
    $var wire  1 8 EQ $end
    $var wire 32 + ImmOp [31:0] $end
    $var wire  1 7 RegWrite $end
    $var wire 32 = a0 [31:0] $end
    $var wire  1 ; clk $end
    $var wire  5 1 rd [4:0] $end
    $var wire 32 & regop2 [31:0] $end
    $var wire  5 / rs1 [4:0] $end
    $var wire  5 0 rs2 [4:0] $end
    $scope module ALU $end
     $var wire  1 5 ALUctrl $end
     $var wire 32 % ALUop1 [31:0] $end
     $var wire 32 : ALUop2 [31:0] $end
     $var wire 32 > ALUout [31:0] $end
     $var wire  1 8 EQ $end
    $upscope $end
    $scope module Mux2 $end
     $var wire 32 : ALUop2 [31:0] $end
     $var wire  1 6 ALUsrc $end
     $var wire 32 + ImmOp [31:0] $end
     $var wire 32 & RegOp2 [31:0] $end
    $upscope $end
    $scope module REG_FILE $end
     $var wire  5 / AD1 [4:0] $end
     $var wire  5 0 AD2 [4:0] $end
     $var wire  5 1 AD3 [4:0] $end
     $var wire 32 @ ADDRESS_WIDTH [31:0] $end
     $var wire 32 @ DATA_WIDTH [31:0] $end
     $var wire 32 % RD1 [31:0] $end
     $var wire 32 & RD2 [31:0] $end
     $var wire 32 > WD3 [31:0] $end
     $var wire  1 7 WE3 $end
     $var wire 32 = a0 [31:0] $end
     $var wire  1 ; clk $end
     $var wire 32 ' ram_array[-1] [31:0] $end
     $var wire 32 ( ram_array[0] [31:0] $end
    $upscope $end
   $upscope $end
   $scope module SignExtend $end
    $var wire 32 @ DATA_WIDTH [31:0] $end
    $var wire 32 A IMM_WIDTH [31:0] $end
    $var wire 12 ? Imm [11:0] $end
    $var wire 12 2 Imm1 [11:0] $end
    $var wire 12 3 Imm2 [11:0] $end
    $var wire 32 + ImmOp [31:0] $end
    $var wire  1 9 ImmSrc $end
    $var wire 32 * instr [31:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b00000000 #
b00000000 $
b00000000000000000000000000000000 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 (
b00000000000000000000000000000000 )
b00000000000000000000000000000000 *
b00000000000000000000000000000000 +
b0000000 ,
0-
0.
b00000 /
b00000 0
b00000 1
b000000000000 2
b000000000000 3
04
05
06
07
08
09
b00000000000000000000000000000000 :
1;
1<
b00000000000000000000000000000000 =
b00000000000000000000000000000000 >
b000000000000 ?
b00000000000000000000000000100000 @
b00000000000000000000000000001100 A
